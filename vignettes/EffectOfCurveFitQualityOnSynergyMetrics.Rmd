---
title: "Effect of Curve Fit Quality on Synergy Metrics"
author:
- name: Christopher Eeles
  affiliation: &pm Princess Margaret Cancer Centre, University Health Network, Toronto Canada
  email: christopher.eeles@uhnresearch.ca
- name: Feifei Li
  affiliation: &ccb Department of Cell & System Biology, University of Toronto, Toronto Canada
- name: Petr Smirnov
  affiliation:
    - *pm
    - &mbp Department of Medical Biophysics, University of Toronto, Toronto Canada
  email: psmirnov@utoronto.ca
- name: Benjamin Haibe-Kains
  affiliation:
    - *pm
    - *mbp
  email: benjamin.haibe.kains@utoronto.ca
output:
  BiocStyle::html_document
abstract: |
  Monotherapy fit quality has a significant impact on the variability of curve
  based synergy metrics such as Loewe Additivty and ZIP Delta.
bibliography: drugCombos.bib
vignette: |
  %\VignetteIndexEntry{Effect of Curve Fit Quality on Synergy Metrics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r eval=TRUE, include=FALSE}
cgx <- BiocStyle::Biocpkg("CoreGx")
pgx <- BiocStyle::Biocpkg("PharmacoGx")
```

# Drug Combinations Tutorial

For a comprehensive introduction to drug combination modelling with `r cgx` and
`r pgx`, please see our
[workshop from BioC2022](http://bhklab.ca/bioc2022workshop/articles/PGxWorkshop.html).

# Mathews Griner

```{r}
library(PharmacoGx)
library(CoreGx)
library(data.table)
library(ggplot2)
```

## Reading in Raw Data

```{r}
input_file <- file.path("mathews_griner.csv.tar.gz")
mathews_griner <- fread(input_file)
```

## Experimental Design Hypothesis

```{r}
groups <- list(
    rowDataMap=c(
        treatment1id="RowName", treatment2id="ColName",
        treatment1dose="RowConcs", treatment2dose="ColConcs"
    ),
    colDataMap=c("sampleid")
)
groups[["assayMap"]] <- c(groups$rowDataMap, groups$colDataMap)
(groups)
```

## Handling Undocumented Replicates

```{r}
mathews_griner[, tech_rep := seq_len(.N), by=c(groups[["assayMap"]])]
if (max(mathews_griner[["tech_rep"]]) > 1) {
    groups[["colDataMap"]] <- c(groups[["colDataMap"]], "tech_rep")
    groups[["assayMap"]] <- c(groups[["assayMap"]], "tech_rep")
} else {
    # delete the additional column if not needed
    mathews_griner[["tech_reps"]] <- NULL
}
```

## Using the `TREDataMapper`

```{r}
(treMapper <- TREDataMapper(rawdata=mathews_griner))
```

```{r}
guess <- guessMapping(treMapper, groups, subset=TRUE)
```

```{r}
metadataMap(treMapper) <- list(experiment_metadata=guess$metadata$mapped_columns)
rowDataMap(treMapper) <- guess$rowDataMap
colDataMap(treMapper) <- guess$colDataMap
assayMap(treMapper) <- list(raw=guess$assayMap)
```

## Creating a `TreatmentResponseExperiment`

```{r}
(tre <- metaConstruct(treMapper))
```

## Normalizing Treatment Response

```{r}
raw <- tre[["raw"]]
raw[,
    viability := viability / .SD[treatment1dose == 0 & treatment2dose == 0, viability],
    by=c("treatment1id", "treatment2id", "sampleid", "tech_rep")
]
raw[, viability := pmax(0, viability)]
tre[["raw"]] <- raw
```

```{r}
tre[["raw"]][, range(viability)]
```

```{r}
bad_treatments <- tre[["raw"]][viability > 2, unique(treatment1id)]
```

```{r}
## TODO:: Debug warning message!
tre <- subset(tre, !(treatment1id %in% bad_treatments))
```

```{r}
tre[["raw"]][, range(viability)]
```

## Fitting Monotherapy Curves

```{r}
tre_qc <- tre |>
    endoaggregate(
        subset=treatment2dose == 0,  # filter to only monotherapies
        assay="raw",  # filter from the "raw" assay
        target="mono_viability", # assign result to the "mono_viability" assay
        mean_viability=pmin(1, mean(viability)),  # aggregation to compute
        by=c("treatment1id", "treatment1dose", "sampleid")  # grouping for aggregation
    )
```

```{r}
# ## QC on the variablity of fits for biological replicates of Ibrutinib monotherapy
# tre |>
#     aggregate(
#         subset=treatment1dose == 0,
#         assay="raw",
#         mean_viability=pmin(1.05, mean(viability)),
#         by=c("treatment1id", "treatment2dose", "sampleid")
#     ) -> control_df

# control_df[,
#     {
#         fit <- logLogisticRegression(
#             treatment2dose,
#             mean_viability,
#             viability_as_pct=FALSE
#         )
#         c(fit, Rsquare=attributes(fit)$Rsquare)
#     },
#     by=c("treatment1id", "sampleid")
# ] -> control_fits

# p <- ggplot(control_df, aes(x=mean_viability)) +
#     geom_histogram() +
#     facet_wrap(~treatment2dose)
```

```{r}
tre_fit <- tre_qc |>
    endoaggregate(
        {
            fit <- logLogisticRegression(treatment1dose, mean_viability,
                viability_as_pct=FALSE)
            ic50 <- computeIC50(treatment1dose, Hill_fit=fit)
            aac <- computeAUC(treatment1dose, Hill_fit=fit)
            list(
                HS=fit[["HS"]],
                E_inf = fit[["E_inf"]],
                EC50 = fit[["EC50"]],
                Rsq=as.numeric(unlist(attributes(fit))),
                aac_recomputed=aac,
                ic50_recomputed=ic50
            )
        },
        assay="mono_viability",
        target="mono_profiles",
        enlist=FALSE,
        by=c("treatment1id", "sampleid"),
        nthread=4
    )
```

```{r}
mono_fits <- tre_fit$mono_profiles |>
    merge(tre_fit$mono_viability, by=c("treatment1id", "sampleid"))
mono_plots <- split(mono_fits, by=c("treatment1id", "sampleid"))
```

```{r}
# Add the hill curve viability predictions
mono_fits[,
    log10_treatment1dose := log10(
        ifelse(treatment1dose == 0, 1, treatment1dose) # No Inf!
    )
]
mono_fits[,
    pred_viability := hillCurve(
        dose=log10_treatment1dose,
        HS=unique(HS),
        E_inf=unique(E_inf),
        EC50=log10(EC50),
        E_ninf=1),
    by=.(treatment1id, sampleid)
]
```

```{r}
# Test out clustering curves by parameters
hill_df <- tre_fit[["mono_profiles"]][,
    .(HS, EC50, E_inf)
] |> as.data.frame()
rownames(hill_df) <- tre_fit[["mono_profiles"]]$treatment1id
hill_euclidean <- dist(hill_df)
hill_hc_ward <- hclust(hill_euclidean, method="ward.D2")
# Test out clustering curves by actual viabilities
viab_df <- mono_fits |>
    dcast(treatment1id ~ treatment1dose, value.var="mean_viability") |>
    as.data.frame()
rownames(viab_df) <- viab_df$treatment1id
viab_euclidean <- dist(viab_df)
viab_hc_ward <- hclust(viab_euclidean, method="ward.D2")
# Test out clustering curves by predicted viabilities
pviab_df <- mono_fits |>
    dcast(treatment1id ~ treatment1dose, value.var="pred_viability") |>
    as.data.frame()
rownames(pviab_df) <- pviab_df$treatment1id
pviab_euclidean <- dist(pviab_df)
pviab_hc_ward <- hclust(pviab_euclidean, method="ward.D2")
```

```{r}
plot(hill_hc_ward, cex=0.6)
plot(viab_hc_ward, cex=0.6)
plot(pviab_hc_ward, cex=0.6)
```

```{r}
hill_hc_labs <- cutree(hill_hc_ward, k=4)
viab_hc_labs <- cutree(viab_hc_ward, k=4)
pviab_hc_labs <- cutree(pviab_hc_ward, k=4)
```

```{r}
mono_fits[, hill_clust := hill_hc_labs[treatment1id]]
mono_fits[, viab_clust := viab_hc_labs[treatment1id]]
mono_fits[, pviab_clust := pviab_hc_labs[treatment1id]]
```

```{r}
mono_fits[,
    viab_clust_label :=
        paste(
            viab_clust,
            "Rsqr:",
            paste0(round(range(Rsq, na.rm=TRUE), 2), collapse=", "),
            "n:",
            uniqueN(treatment1id),
            sep=" "
        ),
    by=viab_clust
]
mono_fits[,
    hill_clust_label :=
        paste(
            hill_clust,
            "Rsqr:",
            paste0(round(range(Rsq, na.rm=TRUE), 2), collapse=", "),
            "n:",
            uniqueN(treatment1id),
            sep=" "
        ),
    by=hill_clust
]
mono_fits[,
    hill_clust_label :=
        paste(
            pviab_clust,
            "Rsqr:",
            paste0(round(range(Rsq, na.rm=TRUE), 2), collapse=", "),
            "n:",
            uniqueN(treatment1id),
            sep=" "
        ),
    by=pviab_clust
]
```

```{r}
mono_fits |>
    ggplot(aes(x=log10_treatment1dose, y=pred_viability)) +
    stat_smooth(
        method="glm",
        method.args=list(family="binomial"),
        span=0.3
    ) +
    facet_wrap(~hill_clust_label)
```

```{r}
mono_fits |>
    ggplot(aes(x=log10_treatment1dose, y=pred_viability)) +
    stat_smooth(
        method="glm",
        method.args=list(family="binomial"),
        span=0.3
    ) +
    facet_wrap(~viab_clust_label)
```

```{r}
mono_fits |>
    ggplot(aes(x=viab_clust_label, y=Rsq)) +
    geom_boxplot() +
    scale_y_continuous(limits=c(-2, 1))
```

```{r}
plots <- lapply(mono_plots, \(df) {
    df[,
        .SD |>
        ggplot(aes(x=log10(ifelse(treatment1dose == 0, 1., treatment1dose)))) +
        geom_function(
            fun=\(x)
                hillCurve(dose=x,
                HS=unique(.SD$HS),
                E_inf=unique(.SD$E_inf),
                EC50=log10(unique(.SD$EC50)),
                E_ninf=1)
        ) +
        geom_point(aes(y=mean_viability)) +
        xlab("log10(treatment1dose)")
    ]
})
```


```{r}
mono_fits[, plot(density(E_inf, na.rm=TRUE))]
```


## Joining Monotherapy Curve Fits to Combinations

```{r}
tre_combo <- tre_fit |>
    endoaggregate(
        assay="raw",
        target="combo_viability",
        mean(viability),
        by=c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose", "sampleid")
    )
```

```{r}
tre_combo <- tre_combo |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by=c("treatment1id", "sampleid")
    ) |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by.x=c("treatment2id", "sampleid"),
        by.y=c("treatment1id", "sampleid"),
        suffixes=c("_1", "_2")
    )
```


```{r}
tre_combo <- tre_combo |>
    endoaggregate(
        viability_1=.SD[treatment2dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment1dose", "sampleid")
    ) |>
    endoaggregate(
        viability_2=.SD[treatment1dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment2dose", "sampleid")
    )
```

## Compute Synergy Scores

```{r}
tre_synergy <- tre_combo |>
    endoaggregate(
        assay="combo_viability",
        HSA_ref=computeHSA(viability_1, viability_2),
        Bliss_ref=computeBliss(viability_1, viability_2),
        Loewe_ref=computeLoewe(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        ZIP_ref=computeZIP(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        by=assayKeys(tre_combo, "combo_viability"),
        nthread=4
    )
```

```{r}
tre_synergy <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        HSA_score=HSA_ref - mean_viability,
        Bliss_score=Bliss_ref - mean_viability,
        Loewe_score=Loewe_ref - mean_viability,
        ZIP_score=ZIP_ref - mean_viability,
        by=assayKeys(tre_synergy, "combo_viability")
    )
```


```{r}
tre_zip <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment2dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment1dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment2dose),
                EC50_add=unique(EC50_2),
                HS_add=unique(HS_2),
                E_inf_add=unique(E_inf_2),
                residual="normal"
            )
            setNames(zip_fit, paste0(names(zip_fit), "_2_to_1"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment2dose", "sampleid"),
        nthread=10
    )
tre_zip <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment1dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment2dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment1dose),
                EC50_add=unique(EC50_1),
                HS_add=unique(HS_1),
                E_inf_add=unique(E_inf_1),
                residual="normal"
            )
            setNames(zip_fit, paste0(names(zip_fit), "_1_to_2"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment1dose", "sampleid"),
        nthread=10
    )
```

```{r}
tre_zip1 <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        ZIP_delta=.deltaScore(
            EC50_1_to_2=EC50_proj_1_to_2, EC50_2_to_1=EC50_proj_2_to_1,
            EC50_1=EC50_1, EC50_2=EC50_2,
            HS_1_to_2=HS_proj_1_to_2, HS_2_to_1=HS_proj_2_to_1,
            HS_1=HS_1, HS_2=HS_2,
            E_inf_2_to_1=E_inf_proj_2_to_1, E_inf_1_to_2=E_inf_proj_1_to_2,
            E_inf_1=E_inf_1, E_inf_2=E_inf_2,
            treatment1dose=treatment1dose, treatment2dose=treatment2dose
        ),
        by=assayKeys(tre_zip, "combo_viability")
    )
```

## Visualizing Drug Synergy

```{r}
combo_viab <- tre_zip1[["combo_viability"]]
top_15_combo <- combo_viab[
    Rsq_1 > 0.5 & Rsqr_1_to_2 > 0.5 & Rsqr_2_to_1 > 0.5,
    .(delta=max(ZIP_delta, na.rm=TRUE)),
    by=.(treatment1id, treatment2id, sampleid)
][
    order(-delta),
    unique(.SD),
    .SDcols=c('treatment1id', 'treatment2id', 'sampleid')
][1:15]
top_15_combo_df <- combo_viab[top_15_combo, on=c('treatment1id', 'treatment2id', 'sampleid')]
```

```{r}
library(ggplot2)
library(RColorBrewer)
top_15_combo_df |>
    ggplot(aes(x=treatment1dose, y=treatment2dose)) +
    geom_contour_filled(aes(z=ZIP_delta), bins=11) +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_brewer(palette="RdBu")
```

```{r}
Rsq_cut_off <- seq(0, 0.8, 0.1)
spearman <- list()
n_drugs <- c()
for (cutoff in Rsq_cut_off) {
    df_ <- combo_viab[
        Rsq_1 >= cutoff &
            Rsq_2 >= cutoff &
            Rsqr_1_to_2 >= cutoff &
            Rsqr_2_to_1 >= cutoff,
    ]
    n_drugs <- df_[, uniqueN(.SD[, .(treatment1id, treatment2id)])]
    tmp_df <- df_[,
            cor(.SD[, .(Bliss_score, HSA_score, Loewe_score, ZIP_delta)],
                use="complete", method="spearman")
        ] |>
        as.data.table(keep.rownames="score") |>
        melt(id.vars="score", variable.factor=FALSE)
    tmp_df$n_drugs <- n_drugs
    tmp_df$prop_drugs <- n_drugs / combo_viab[, uniqueN(treatment1id, treatment2id)]
    spearman <- c(spearman, list(tmp_df))
}
names(spearman) <- Rsq_cut_off
spearman_df <- rbindlist(spearman, idcol="Rsquare")
spearman_df[, Rsquare := as.numeric(Rsquare)]
spearman_df[, label := paste(score, variable, sep=".")]
```


```{r}
cutoffs <- spearman_df[, unique(Rsquare)]
ndrugs <- spearman_df[, unique(n_drugs)]
spearman_df[score != variable, ] |>
    ggplot(aes(x=Rsquare, y=value, colour=score)) +
    geom_point() +
    geom_smooth() +
    scale_x_continuous(
        sec.axis=dup_axis(
            name="Number of compound pairs",
            breaks=cutoffs,
            labels=ndrugs
        )
    ) +
    xlab("Rsquare cut-off") +
    ylab("Spearman's rho") +
    facet_wrap(~variable)
```

```{r}
library(ggplot2)
libary(RColorBrewer)
top_15_combo_df |>
    ggplot(aes(x=treatment1dose, y=treatment2dose, z=zip_delta)) +
    scale_x_log10(oob=scales::squish_infinite) +
    scale_y_log10(oob=scales::squish_infinite) +
    geom_contour_filled() +
    geom_contour(colour="black") +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_brewer(palette="RdBu")
```

```{r}
top_15_combo_df |>
    ggplot(aes(x=factor(treatment1dose), y=factor(treatment2dose))) +
    geom_tile(aes(fill=zip_delta)) +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_gradient2(low="blue", mid="white", high="red")
```

```{r}
combo_viab[treatment1id %ilike% "Isp|Cane", ] |>
    ggplot(aes(x=factor(treatment1dose), y=factor(treatment2dose))) +
    geom_tile(aes(fill=zip_delta)) +
    facet_wrap(~treatment1id) +
    scale_fill_gradient2(low="blue", mid="white", high="red")
```

# References


# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
