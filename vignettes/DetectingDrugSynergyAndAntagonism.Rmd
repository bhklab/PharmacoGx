---
title: "Detecting Drug Synergy and Antagnoism with PharmacoGx 3.0"
author:
- name: Christopher Eeles
  affiliation: &pm Princess Margaret Cancer Centre, University Health Network, Toronto Canada
  email: christopher.eeles@uhnresearch.ca
- name: Feifei Li
  affiliation: &ccb Department of Cell & System Biology, University of Toronto, Toronto Canada
- name: Petr Smirnov
  affiliation:
    - *pm
    - &mbp Department of Medical Biophysics, University of Toronto, Toronto Canada
  email: psmirnov@utoronto.ca
- name: Benjamin Haibe-Kains
  affiliation:
    - *pm
    - *mbp
  email: benjamin.haibe.kains@utoronto.ca
output:
  BiocStyle::html_document
abstract: |
  Drug combinations are an effective strategy to over come incomplete response
  or acquired resistance to monotherapies in clinical oncology and beyond. As
  such, detecting molecular signatures of drug synergy or antagonism in
  pre-clinical model systems is a major priority to accelerate the adoption of
  novel treatment strategies in the clinic. The release of PharmacoGx 3.0
  introduces support for storing, analyzying and visualizing the results of drug
  combination experiments using the PharmacoSet class, and will enable
  reseachers across a range of disciplines to more easily mine the published
  drug combination literature for promising signatures of synergy or antagonism
  which can be validated in retrospective patient data and prioritized
  for prospective clinical trails.
bibliography: drugCombos.bib
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r eval=TRUE, include=FALSE}
cgx <- BiocStyle::Biocpkg("CoreGx")
pgx <- BiocStyle::Biocpkg("PharmacoGx")
```

# Drug Combinations Tutorial

For a comprehensive introduction to drug combination modelling with `r cgx` and
`r pgx`, please see our
[workshop from BioC2022](http://bhklab.ca/bioc2022workshop/articles/PGxWorkshop.html).

# Mathews Griner

```{r}
library(PharmacoGx)
library(CoreGx)
library(data.table)
library(ggplot2)
```

## Reading in Raw Data

```{r}
input_file <- file.path("mathews_griner.csv.tar.gz")
mathews_griner <- fread(input_file)
```

## Experimental Design Hypothesis

```{r}
groups <- list(
    rowDataMap=c(
        treatment1id="RowName", treatment2id="ColName",
        treatment1dose="RowConcs", treatment2dose="ColConcs"
    ),
    colDataMap=c("sampleid")
)
groups[["assayMap"]] <- c(groups$rowDataMap, groups$colDataMap)
(groups)
```

## Handling Undocumented Replicates

```{r}
mathews_griner[, tech_rep := seq_len(.N), by=c(groups[["assayMap"]])]
if (max(mathews_griner[["tech_rep"]]) > 1) {
    groups[["colDataMap"]] <- c(groups[["colDataMap"]], "tech_rep")
    groups[["assayMap"]] <- c(groups[["assayMap"]], "tech_rep")
} else {
    # delete the additional column if not needed
    mathews_griner[["tech_reps"]] <- NULL
}
```

## Using the `TREDataMapper`

```{r}
(treMapper <- TREDataMapper(rawdata=mathews_griner))
```

```{r}
guess <- guessMapping(treMapper, groups, subset=TRUE)
```

```{r}
metadataMap(treMapper) <- list(experiment_metadata=guess$metadata$mapped_columns)
rowDataMap(treMapper) <- guess$rowDataMap
colDataMap(treMapper) <- guess$colDataMap
assayMap(treMapper) <- list(raw=guess$assayMap)
```

## Creating a `TreatmentResponseExperiment`

```{r}
(tre <- metaConstruct(treMapper))
```

## Normalizing Treatment Response

```{r}
raw <- tre[["raw"]]
raw[,
    viability := viability / .SD[treatment1dose == 0 & treatment2dose == 0, viability],
    by=c("treatment1id", "treatment2id", "sampleid", "tech_rep")
]
raw[, viability := pmax(0, viability)]
tre[["raw"]] <- raw
```

```{r}
tre[["raw"]][, range(viability)]
```

```{r}
bad_treatments <- tre[["raw"]][viability > 2, unique(treatment1id)]
```

```{r}
## TODO:: Debug warning message!
tre <- subset(tre, !(treatment1id %in% bad_treatments))
```

```{r}
tre[["raw"]][, range(viability)]
```

## Fitting Monotherapy Curves

```{r}
tre_qc <- tre |>
    endoaggregate(
        subset=treatment2dose == 0,
        assay="raw",
        target="mono_viability",
        mean_viability=pmin(1, mean(viability)),
        by=c("treatment1id", "treatment1dose", "sampleid")
    )
```

```{r}
## QC on the variablity of fits for biological replicates of Ibrutinib monotherapy
# tre |>
#     aggregate(
#         subset=treatment1dose == 0,
#         assay="raw",
#         mean_viability=pmin(1.05, mean(viability)),
#         by=c("treatment1id", "treatment2dose", "sampleid")
#     ) -> control_df

# control_df[,
#     {
#         fit <- logLogisticRegression(
#             treatment2dose,
#             mean_viability,
#             viability_as_pct=FALSE
#         )
#         c(fit, Rsquare=attributes(fit)$Rsquare)
#     },
#     by=c("treatment1id", "sampleid")
# ] -> control_fits

# p <- ggplot(control_df, aes(x=mean_viability)) +
#     geom_density() +
#     facet_wrap(~treatment2dose)
```

```{r}
tre_fit <- tre_qc |>
    endoaggregate(
        {
            fit <- logLogisticRegression(treatment1dose, mean_viability,
                viability_as_pct=FALSE)
            ic50 <- computeIC50(treatment1dose, Hill_fit=fit)
            aac <- computeAUC(treatment1dose, Hill_fit=fit)
            list(
                HS=fit[["HS"]],
                E_inf = fit[["E_inf"]],
                EC50 = fit[["EC50"]],
                Rsq=as.numeric(unlist(attributes(fit))),
                aac_recomputed=aac,
                ic50_recomputed=ic50
            )
        },
        assay="mono_viability",
        target="mono_profiles",
        enlist=FALSE,
        by=c("treatment1id", "sampleid"),
        nthread=4
    )
```

```{r}
mono_fits <- tre_fit$mono_profiles |>
    merge(tre_fit$mono_viability, by=c("treatment1id", "sampleid"))
mono_plots <- split(mono_fits, by=c("treatment1id", "sampleid"))
```

```{r}
# Add the hill curve viability predictions
mono_fits[,
    log10_treatment1dose := log10(
        ifelse(treatment1dose == 0, 1, treatment1dose) # No Inf!
    )
]
mono_fits[,
    pred_viability := hillCurve(
        dose=log10_treatment1dose,
        HS=unique(HS),
        E_inf=unique(E_inf),
        EC50=log10(EC50),
        E_ninf=1),
    by=.(treatment1id, sampleid)
]
```

```{r}
# Test out clustering curves by parameters
hill_df <- tre_fit[["mono_profiles"]][,
    .(HS, EC50, E_inf)
] |> as.data.frame()
rownames(hill_df) <- tre_fit[["mono_profiles"]]$treatment1id
hill_euclidean <- dist(hill_df)
hill_hc_ward <- hclust(hill_euclidean, method="ward.D2")
# Test out clustering curves by actual viabilities
viab_df <- mono_fits |>
    dcast(treatment1id ~ treatment1dose, value.var="mean_viability") |>
    as.data.frame()
rownames(viab_df) <- viab_df$treatment1id
viab_euclidean <- dist(viab_df)
viab_hc_ward <- hclust(viab_euclidean, method="ward.D2")
# Test out clustering curves by predicted viabilities
pviab_df <- mono_fits |>
    dcast(treatment1id ~ treatment1dose, value.var="pred_viability") |>
    as.data.frame()
rownames(pviab_df) <- pviab_df$treatment1id
pviab_euclidean <- dist(pviab_df)
pviab_hc_ward <- hclust(pviab_euclidean, method="ward.D2")
```

```{r}
plot(hill_hc_ward, cex=0.6)
plot(viab_hc_ward, cex=0.6)
plot(pviab_hc_ward, cex=0.6)
```

```{r}
hill_hc_labs <- cutree(hill_hc_ward, k=4)
viab_hc_labs <- cutree(viab_hc_ward, k=4)
pviab_hc_labs <- cutree(pviab_hc_ward, k=4)
```

```{r}
mono_fits[, hill_clust := hill_hc_labs[treatment1id]]
mono_fits[, viab_clust := viab_hc_labs[treatment1id]]
mono_fits[, pviab_clust := pviab_hc_labs[treatment1id]]
```

```{r}
mono_fits[,
    viab_clust_label :=
        paste(
            viab_clust,
            "Rsqr:",
            paste0(round(range(Rsq, na.rm=TRUE), 3), collapse=","),
            "n:",
            uniqueN(treatment1id),
            sep=" "
        ),
    by=viab_clust
]
mono_fits[,
    hill_clust_label :=
        paste(
            hill_clust,
            "Rsqr:",
            paste0(round(range(Rsq, na.rm=TRUE), 3), collapse=","),
            "n:",
            uniqueN(treatment1id),
            sep=" "
        ),
    by=hill_clust
]
mono_fits[,
    hill_clust_label :=
        paste(
            pviab_clust,
            "Rsqr:",
            paste0(round(range(Rsq, na.rm=TRUE), 3), collapse=","),
            "n:",
            uniqueN(treatment1id),
            sep=" "
        ),
    by=pviab_clust
]
```

```{r}
mono_fits |>
    ggplot(aes(x=log10_treatment1dose, y=pred_viability)) +
    stat_smooth(
        method="glm",
        method.args=list(family="binomial"),
        span=0.3
    ) +
    facet_wrap(~hill_clust_label)
```

```{r}
mono_fits |>
    ggplot(aes(x=log10_treatment1dose, y=pred_viability)) +
    stat_smooth(
        method="glm",
        method.args=list(family="binomial"),
        span=0.3
    ) +
    facet_wrap(~viab_clust_label)
```

```{r}
mono_fits |>
    ggplot(aes(x=viab_clust_label, y=Rsq)) +
    geom_boxplot() +
    scale_y_continuous(limits=c(-2, 1))
```

```{r}
plots <- lapply(mono_plots, \(df) {
    df[,
        .SD |>
        ggplot(aes(x=log10(ifelse(treatment1dose == 0, 1., treatment1dose)))) +
        geom_function(
            fun=\(x)
                hillCurve(dose=x,
                HS=unique(.SD$HS),
                E_inf=unique(.SD$E_inf),
                EC50=log10(unique(.SD$EC50)),
                E_ninf=1)
        ) +
        geom_point(aes(y=mean_viability)) +
        xlab("log10(treatment1dose)")
    ]
})
```


```{r}
mono_fits[, plot(density(E_inf, na.rm=TRUE))]
```


## Joining Monotherapy Curve Fits to Combinations

```{r}
tre_combo <- tre_fit |>
    endoaggregate(
        assay="raw",
        target="combo_viability",
        mean(viability),
        by=c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose", "sampleid")
    )
```

```{r}
tre_combo <- tre_combo |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by=c("treatment1id", "sampleid")
    ) |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by.x=c("treatment2id", "sampleid"),
        by.y=c("treatment1id", "sampleid"),
        suffixes=c("_1", "_2")
    )
```


```{r}
tre_combo <- tre_combo |>
    endoaggregate(
        viability_1=.SD[treatment2dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment1dose", "sampleid")
    ) |>
    endoaggregate(
        viability_2=.SD[treatment1dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment2dose", "sampleid")
    )
```

## Compute Synergy Scores

```{r}
tre_synergy <- tre_combo |>
    endoaggregate(
        assay="combo_viability",
        HSA_ref=computeHSA(viability_1, viability_2),
        Bliss_ref=computeBliss(viability_1, viability_2),
        Loewe_ref=computeLoewe(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        ZIP_ref=computeZIP(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        by=assayKeys(tre_combo, "combo_viability"),
        nthread=4
    )
```

```{r}
tre_synergy <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        HSA_score=HSA_ref - mean_viability,
        Bliss_score=Bliss_ref - mean_viability,
        Loewe_score=Loewe_ref - mean_viability,
        ZIP_score=ZIP_ref - mean_viability,
        by=assayKeys(tre_synergy, "combo_viability")
    )
```


```{r}
tre_zip <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment2dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment1dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment2dose),
                EC50_add=unique(EC50_2),
                HS_add=unique(HS_2),
                E_inf_add=unique(E_inf_2),
                residual="normal"
            )
            setNames(zip_fit, paste0(names(zip_fit), "_2_to_1"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment2dose", "sampleid"),
        nthread=10
    )
tre_zip <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment1dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment2dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment1dose),
                EC50_add=unique(EC50_1),
                HS_add=unique(HS_1),
                E_inf_add=unique(E_inf_1),
                residual="normal"
            )
            setNames(zip_fit, paste0(names(zip_fit), "_1_to_2"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment1dose", "sampleid"),
        nthread=10
    )
```

```{r}
tre_zip1 <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        ZIP_delta=.deltaScore(
            EC50_1_to_2=EC50_proj_1_to_2, EC50_2_to_1=EC50_proj_2_to_1,
            EC50_1=EC50_1, EC50_2=EC50_2,
            HS_1_to_2=HS_proj_1_to_2, HS_2_to_1=HS_proj_2_to_1,
            HS_1=HS_1, HS_2=HS_2,
            E_inf_2_to_1=E_inf_proj_2_to_1, E_inf_1_to_2=E_inf_proj_1_to_2,
            E_inf_1=E_inf_1, E_inf_2=E_inf_2,
            treatment1dose=treatment1dose, treatment2dose=treatment2dose
        ),
        by=assayKeys(tre_zip, "combo_viability")
    )
```

## Visualizing Drug Synergy

```{r}
combo_viab <- tre_zip1[["combo_viability"]]
top_15_combo <- combo_viab[
    Rsq_1 > 0.5 & Rsqr_1_to_2 > 0.5 & Rsqr_2_to_1 > 0.5,
    .(delta=max(ZIP_delta, na.rm=TRUE)),
    by=.(treatment1id, treatment2id, sampleid)
][
    order(-delta),
    unique(.SD),
    .SDcols=c('treatment1id', 'treatment2id', 'sampleid')
][1:15]
top_15_combo_df <- combo_viab[top_15_combo, on=c('treatment1id', 'treatment2id', 'sampleid')]
```

```{r}
library(ggplot2)
library(RColorBrewer)
top_15_combo_df |>
    ggplot(aes(x=treatment1dose, y=treatment2dose)) +
    geom_contour_filled(aes(z=ZIP_delta), bins=11) +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_brewer(palette="RdBu")
```

```{r}
Rsq_cut_off <- seq(0, 0.8, 0.1)
spearman <- list()
n_drugs <- c()
for (cutoff in Rsq_cut_off) {
    df_ <- combo_viab[
        Rsq_1 >= cutoff &
            Rsq_2 >= cutoff &
            Rsqr_1_to_2 >= cutoff &
            Rsqr_2_to_1 >= cutoff,
    ]
    n_drugs <- df_[, uniqueN(.SD[, .(treatment1id, treatment2id)])]
    tmp_df <- df_[,
            cor(.SD[, .(Bliss_score, HSA_score, Loewe_score, ZIP_delta)],
                use="complete", method="spearman")
        ] |>
        as.data.table(keep.rownames="score") |>
        melt(id.vars="score", variable.factor=FALSE)
    tmp_df$n_drugs <- n_drugs
    tmp_df$prop_drugs <- n_drugs / combo_viab[, uniqueN(treatment1id, treatment2id)]
    spearman <- c(spearman, list(tmp_df))
}
names(spearman) <- Rsq_cut_off
spearman_df <- rbindlist(spearman, idcol="Rsquare")
spearman_df[, Rsquare := as.numeric(Rsquare)]
spearman_df[, label := paste(score, variable, sep=".")]
```


```{r}
cutoffs <- spearman_df[, unique(Rsquare)]
ndrugs <- spearman_df[, unique(n_drugs)]
spearman_df[score != variable, ] |>
    ggplot(aes(x=Rsquare, y=value, colour=score)) +
    geom_point() +
    geom_smooth() +
    scale_x_continuous(
        sec.axis=dup_axis(
            name="Number of compound pairs",
            breaks=cutoffs,
            labels=ndrugs
        )
    ) +
    xlab("Rsquare cut-off") +
    ylab("Spearman's rho") +
    facet_wrap(~variable)
```

```{r}
library(ggplot2)
libary(RColorBrewer)
top_15_combo_df |>
    ggplot(aes(x=treatment1dose, y=treatment2dose, z=zip_delta)) +
    scale_x_log10(oob=scales::squish_infinite) +
    scale_y_log10(oob=scales::squish_infinite) +
    geom_contour_filled() +
    geom_contour(colour="black") +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_brewer(palette="RdBu")
```

```{r}
top_15_combo_df |>
    ggplot(aes(x=factor(treatment1dose), y=factor(treatment2dose))) +
    geom_tile(aes(fill=zip_delta)) +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_gradient2(low="blue", mid="white", high="red")
```

```{r}
combo_viab[treatment1id %ilike% "Isp|Cane", ] |>
    ggplot(aes(x=factor(treatment1dose), y=factor(treatment2dose))) +
    geom_tile(aes(fill=zip_delta)) +
    facet_wrap(~treatment1id) +
    scale_fill_gradient2(low="blue", mid="white", high="red")
```

# References
****

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
